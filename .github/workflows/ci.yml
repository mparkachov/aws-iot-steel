name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v5
    
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
    
    - name: Cache cargo dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry/index
          ~/.cargo/registry/cache
          ~/.cargo/git/db
          target
        key: ${{ runner.os }}-cargo-quality-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-quality-
          ${{ runner.os }}-cargo-
    
    - name: Check formatting
      run: cargo fmt --all -- --check
    
    - name: Run clippy
      run: cargo clippy --workspace --all-targets --all-features -- -D warnings
    
    - name: Install cargo-audit
      run: cargo install cargo-audit
    
    - name: Security audit
      run: cargo audit

  test-linux:
    name: Test on Linux (CI/CD Platform)
    runs-on: ubuntu-latest
    needs: code-quality
    steps:
    - uses: actions/checkout@v5
    
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
    
    - name: Cache cargo dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry/index
          ~/.cargo/registry/cache
          ~/.cargo/git/db
          target
        key: ${{ runner.os }}-cargo-test-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-test-
          ${{ runner.os }}-cargo-quality-
          ${{ runner.os }}-cargo-
    
    - name: Build project
      run: |
        # Build all library crates
        cargo build --workspace --lib --verbose
        # Build platform-agnostic examples
        cargo build --bin basic_hal_demo --package aws-iot-examples --verbose
    
    - name: Run Rust unit tests
      run: cargo test --workspace --lib --verbose
    
    - name: Run Rust integration tests
      run: cargo test --workspace --test '*' --verbose
    
    - name: Test Linux platform specifically
      run: |
        cargo test --package aws-iot-platform-linux --verbose
        cargo run --bin linux_ci_demo --package aws-iot-examples
    
    - name: Run Steel test suite
      run: |
        # Use Linux platform for testing in CI
        export AWS_IOT_PLATFORM=linux
        cargo run --bin steel_test --package aws-iot-core -- --verbose
    
    - name: Run Steel examples
      run: |
        # Use Linux platform for testing in CI
        export AWS_IOT_PLATFORM=linux
        cargo run --bin steel_example --package aws-iot-core -- --verbose

  cross-compile-esp32:
    name: Cross-compile for ESP32-C3-DevKit-RUST-1
    runs-on: ubuntu-latest
    needs: code-quality
    steps:
    - uses: actions/checkout@v5
    
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: riscv32imc-esp-espidf
    
    - name: Cache cargo dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry/index
          ~/.cargo/registry/cache
          ~/.cargo/git/db
          target
        key: ${{ runner.os }}-cargo-esp32-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-esp32-
          ${{ runner.os }}-cargo-test-
          ${{ runner.os }}-cargo-
    
    - name: Install ESP-IDF prerequisites
      run: |
        sudo apt-get update
        sudo apt-get install -y git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0
    
    - name: Cache ESP toolchain
      uses: actions/cache@v4
      with:
        path: |
          ~/.espressif
          ~/.cargo/bin/espup
          ~/.cargo/bin/ldproxy
        key: ${{ runner.os }}-esp-toolchain-${{ hashFiles('.github/workflows/ci.yml') }}
        restore-keys: |
          ${{ runner.os }}-esp-toolchain-
    
    - name: Install espup
      run: |
        if ! command -v espup &> /dev/null; then
          cargo install espup
        fi
        if [ ! -f "$HOME/export-esp.sh" ]; then
          espup install
        fi
        source $HOME/export-esp.sh
    
    - name: Install ldproxy
      run: |
        if ! command -v ldproxy &> /dev/null; then
          cargo install ldproxy
        fi
    
    - name: Cross-compile for ESP32-C3
      run: |
        source $HOME/export-esp.sh
        cargo build --target riscv32imc-esp-espidf --package aws-iot-platform-esp32 --verbose
    
    - name: Build ESP32 firmware binary
      run: |
        source $HOME/export-esp.sh
        cargo build --target riscv32imc-esp-espidf --package aws-iot-platform-esp32 --release
        # Generate firmware binary
        esptool.py --chip esp32c3 elf2image --flash_mode dio --flash_freq 80m --flash_size 4MB target/riscv32imc-esp-espidf/release/aws-iot-platform-esp32
    
    - name: Upload ESP32 firmware artifacts
      uses: actions/upload-artifact@v4
      with:
        name: esp32-firmware
        path: |
          target/riscv32imc-esp-espidf/release/aws-iot-platform-esp32
          target/riscv32imc-esp-espidf/release/aws-iot-platform-esp32.bin
        retention-days: 30

  build-and-sign:
    name: Build and Sign Firmware
    runs-on: ubuntu-latest
    needs: [test-linux, cross-compile-esp32]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    steps:
    - uses: actions/checkout@v5
    
    - name: Download ESP32 firmware artifacts
      uses: actions/download-artifact@v5
      with:
        name: esp32-firmware
        path: ./firmware
    
    - name: Install signing and packaging tools
      run: |
        sudo apt-get update
        sudo apt-get install -y openssl jq
    
    - name: Sign and package firmware
      env:
        FIRMWARE_SIGNING_KEY: ${{ secrets.FIRMWARE_SIGNING_KEY }}
        FIRMWARE_PUBLIC_KEY: ${{ secrets.FIRMWARE_PUBLIC_KEY }}
        GITHUB_SHA: ${{ github.sha }}
        GITHUB_REF_NAME: ${{ github.ref_name }}
      run: |
        ./scripts/sign-firmware.sh ./firmware ./signed-artifacts
    
    - name: Validate signed artifacts
      env:
        FIRMWARE_PUBLIC_KEY: ${{ secrets.FIRMWARE_PUBLIC_KEY }}
      run: |
        VALIDATION_MODE="development"
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          VALIDATION_MODE="strict"
        fi
        ./scripts/validate-artifacts.sh ./signed-artifacts $VALIDATION_MODE
    
    - name: Upload signed artifacts
      uses: actions/upload-artifact@v4
      with:
        name: signed-artifacts
        path: signed-artifacts/
        retention-days: 90
    
    - name: Generate build summary
      run: |
        echo "## 🔐 Firmware Signing Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [[ -f "signed-artifacts/package-manifest.json" ]]; then
          PACKAGE_NAME=$(jq -r '.package_name' signed-artifacts/package-manifest.json)
          PACKAGE_VERSION=$(jq -r '.package_version' signed-artifacts/package-manifest.json)
          PACKAGE_SIZE=$(jq -r '.package_size' signed-artifacts/package-manifest.json)
          PACKAGE_CHECKSUM=$(jq -r '.package_checksum' signed-artifacts/package-manifest.json)
          
          echo "- **Package:** \`$PACKAGE_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`$PACKAGE_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Size:** $(numfmt --to=iec $PACKAGE_SIZE)" >> $GITHUB_STEP_SUMMARY
          echo "- **Checksum:** \`$PACKAGE_CHECKSUM\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Signed:** ✅" >> $GITHUB_STEP_SUMMARY
        fi

  upload-to-aws:
    name: Upload Artifacts to AWS S3
    runs-on: ubuntu-latest
    needs: build-and-sign
    if: github.ref == 'refs/heads/main'
    permissions:
      id-token: write
      contents: read
    steps:
    - uses: actions/checkout@v5
    
    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
        aws-region: ${{ secrets.AWS_REGION }}
        role-session-name: GitHubActions-${{ github.run_id }}
    
    - name: Download signed artifacts
      uses: actions/download-artifact@v5
      with:
        name: signed-artifacts
        path: ./signed-artifacts
    
    - name: Install upload tools
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
    
    - name: Upload artifacts to AWS S3
      env:
        AWS_REGION: ${{ secrets.AWS_REGION }}
        S3_ARTIFACTS_BUCKET: ${{ secrets.S3_BUILD_ARTIFACTS_BUCKET }}
        S3_FIRMWARE_BUCKET: ${{ secrets.S3_FIRMWARE_BUCKET }}
        DEPLOYMENT_STAGE: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
        CODEPIPELINE_NAME: ${{ secrets.CODEPIPELINE_NAME }}
        GITHUB_SHA: ${{ github.sha }}
        GITHUB_REF_NAME: ${{ github.ref_name }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
        GITHUB_RUN_ID: ${{ github.run_id }}
        GITHUB_WORKFLOW: ${{ github.workflow }}
      run: |
        ./scripts/upload-to-aws.sh ./signed-artifacts
    
    - name: Generate deployment summary
      run: |
        echo "## 🚀 AWS Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [[ -f "signed-artifacts/package-manifest.json" ]]; then
          PACKAGE_VERSION=$(jq -r '.package_version' signed-artifacts/package-manifest.json)
          DEPLOYMENT_STAGE=${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
          
          echo "- **Version:** \`$PACKAGE_VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Stage:** \`$DEPLOYMENT_STAGE\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** \`${{ secrets.AWS_REGION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ✅ Uploaded to S3" >> $GITHUB_STEP_SUMMARY
          echo "- **CodePipeline:** Triggered automatically" >> $GITHUB_STEP_SUMMARY
        fi